// PowerTrims Config Builder - JavaScript
// Handles accordion toggling, YAML generation, and file download

// Toggle accordion sections
function toggleAccordion(trimName) {
  const header = event.currentTarget;
  const content = document.getElementById(`accordion-${trimName}`);

  header.classList.toggle('active');
  content.classList.toggle('active');
}

// Get value from input field
function getValue(id, defaultValue = '') {
  const element = document.getElementById(id);
  if (!element) return defaultValue;

  if (element.type === 'checkbox') {
    return element.checked;
  }

  const value = element.value;
  // Try to parse as number if it looks like one
  if (!isNaN(value) && value !== '') {
    return parseFloat(value);
  }
  return value;
}

// Generate full YAML configuration
function generateYAML() {
  return `# POWER-TRIMS Configuration
# Generated by PowerTrims Config Builder
# Website: https://divi922.github.io/PowerTrimsWebsite/

# To reload the configuration, use the command /powertrims reload
# Note: Reload only affects enabling/disabling trims
# To change ability values, restart the server

# Configuration GUI Settings
config-gui:
  # Permission required to access the config GUI (/ptconfig command)
  permission: ${getValue('cfg-permission', 'powertrims.admin')}

# Global settings for enabling or disabling entire trim powers
trims:
  sentry: ${getValue('trim-sentry', true)}
  silence: ${getValue('trim-silence', true)}
  vex: ${getValue('trim-vex', true)}
  ward: ${getValue('trim-ward', true)}
  wild: ${getValue('trim-wild', true)}
  coast: ${getValue('trim-coast', true)}
  dune: ${getValue('trim-dune', true)}
  eye: ${getValue('trim-eye', true)}
  host: ${getValue('trim-host', true)}
  raiser: ${getValue('trim-raiser', true)}
  rib: ${getValue('trim-rib', true)}
  snout: ${getValue('trim-snout', true)}
  spire: ${getValue('trim-spire', true)}
  tide: ${getValue('trim-tide', true)}
  wayfinder: ${getValue('trim-wayfinder', true)}
  flow: ${getValue('trim-flow', true)}
  bolt: ${getValue('trim-bolt', true)}

# ==========================================
# TRIM-SPECIFIC CONFIGURATIONS
# ==========================================

sentry:
  primary:
    arrow_count: ${getValue('sentry-arrow-count', 3)}
    spread: ${getValue('sentry-spread', 0.15)}
    cooldown: ${getValue('sentry-cooldown', 90000)}
    true_damage: ${getValue('sentry-true-damage', 0.5)}

silence:
  primary:
    radius: ${getValue('silence-radius', 15.0)}
    potion_duration: ${getValue('silence-potion-duration', 400)}
    pearl_cooldown: ${getValue('silence-pearl-cooldown', 200)}
    max_affected_entities: ${getValue('silence-max-affected', 30)}
    cooldown: ${getValue('silence-cooldown', 90000)}
  passive:
    cooldown: ${getValue('silence-passive-cooldown', 120000)}
    echo_radius: ${getValue('silence-echo-radius', 6.0)}
    effect_duration: ${getValue('silence-effect-duration', 300)}
  ultimate:
    rage_per_hit_taken: ${getValue('silence-rage-hit-taken', 1.0)}
    rage_per_hit_dealt: ${getValue('silence-rage-hit-dealt', 0.5)}
    max_rage: ${getValue('silence-max-rage', 150.0)}
    warden_duration_seconds: ${getValue('silence-warden-duration', 40)}
    warden_strength_level: ${getValue('silence-warden-strength', 2)}
    warden_health_boost_level: ${getValue('silence-warden-health-boost', 4)}
    warden_resistance_level: ${getValue('silence-warden-resistance', 1)}
    boom_cooldown_seconds: ${getValue('silence-boom-cooldown', 10)}
    boom_damage: ${getValue('silence-boom-damage', 12)}
    boom_length: ${getValue('silence-boom-length', 20.0)}
    boom_aoe_radius: ${getValue('silence-boom-aoe-radius', 3.0)}
    grasp_cooldown_seconds: ${getValue('silence-grasp-cooldown', 15)}
    grasp_radius: ${getValue('silence-grasp-radius', 25.0)}
    grasp_strength: ${getValue('silence-grasp-strength', 2.0)}

vex:
  primary:
    cooldown: ${getValue('vex-cooldown', 120000)}
    radius: ${getValue('vex-radius', 30.0)}
    damage: ${getValue('vex-damage', 8.0)}
    debuff_duration: ${getValue('vex-debuff-duration', 400)}
    blindness_duration: ${getValue('vex-blindness-duration', 100)}
  passive:
    cooldown: ${getValue('vex-passive-cooldown', 120000)}
    hide_duration: ${getValue('vex-hide-duration', 200)}
    health_threshold: ${getValue('vex-health-threshold', 8.0)}

ward:
  primary:
    barrier_duration: ${getValue('ward-barrier-duration', 200)}
    absorption_level: ${getValue('ward-absorption-level', 4)}
    resistance_boost_level: ${getValue('ward-resistance-level', 2)}
    cooldown: ${getValue('ward-cooldown', 120000)}

wild:
  primary:
    cooldown: ${getValue('wild-cooldown', 20000)}
    poison_duration: ${getValue('wild-poison-duration', 200)}
    grapple_range: ${getValue('wild-grapple-range', 60.0)}
    grapple_speed: ${getValue('wild-grapple-speed', 1.8)}
  passive:
    cooldown_seconds: ${getValue('wild-passive-cooldown', 20)}
    trigger_health: ${getValue('wild-trigger-health', 8)}
    root_trap_radius_xz: ${getValue('wild-root-radius-xz', 5.0)}
    root_trap_radius_y: ${getValue('wild-root-radius-y', 3.0)}
    root_trap_duration: ${getValue('wild-root-duration', 200)}
  ultimate:
    duration_seconds: ${getValue('wild-ult-duration', 15)}
    scale_multiplier: ${getValue('wild-scale-multiplier', 1.3)}
    max_health: ${getValue('wild-max-health', 30.0)}
    tether_radius: ${getValue('wild-tether-radius', 12.0)}

coast:
  primary:
    water_burst_radius: ${getValue('coast-water-burst-radius', 30)}
    water_burst_damage: ${getValue('coast-water-burst-damage', 10)}
    water_burst_cooldown: ${getValue('coast-water-burst-cooldown', 60000)}
    pull_duration: ${getValue('coast-pull-duration', 60)}
    debuff_duration: ${getValue('coast-debuff-duration', 80)}
    buff_duration: ${getValue('coast-buff-duration', 100)}
    weakness_amplifier: ${getValue('coast-weakness-amplifier', 1)}
    slowness_amplifier: ${getValue('coast-slowness-amplifier', 1)}
    speed_amplifier: ${getValue('coast-speed-amplifier', 1)}
    resistance_amplifier: ${getValue('coast-resistance-amplifier', 0)}

dune:
  primary:
    cooldown: ${getValue('dune-cooldown', 60000)}
    duration: ${getValue('dune-duration', 200)}
    height: ${getValue('dune-height', 15.0)}
    pull_strength: ${getValue('dune-pull-strength', 0.5)}
    lift_strength: ${getValue('dune-lift-strength', 0.6)}
    damage_per_second: ${getValue('dune-damage-per-second', 2.0)}

eye:
  primary:
    true_sight_radius: ${getValue('eye-true-sight-radius', 80.0)}
    true_sight_duration: ${getValue('eye-true-sight-duration', 600)}
    cooldown: ${getValue('eye-cooldown', 120000)}
    task_interval: ${getValue('eye-task-interval', 20)}
    true_sight_vertical_radius: ${getValue('eye-vertical-radius', 50.0)}

host:
  primary:
    cooldown: ${getValue('host-cooldown', 120000)}
    effect_steal_radius: ${getValue('host-effect-steal-radius', 10.0)}
    health_steal_amount: ${getValue('host-health-steal-amount', 4.0)}
    particle_density: ${getValue('host-particle-density', 4.0)}

raiser:
  primary:
    cooldown: ${getValue('raiser-cooldown', 120000)}
    entity_pull_radius: ${getValue('raiser-entity-pull-radius', 15.0)}
    player_upward_boost: ${getValue('raiser-player-upward-boost', 1.5)}
    pearl_cooldown: ${getValue('raiser-pearl-cooldown', 200)}

rib:
  primary:
    cooldown: ${getValue('rib-cooldown', 60000)}
    minion_lifespan: ${getValue('rib-minion-lifespan', 1200)}

snout:
  primary:
    cooldown: ${getValue('snout-cooldown', 120000)}
    minion_lifespan: ${getValue('snout-minion-lifespan', 1800)}

spire:
  primary:
    dash_distance: ${getValue('spire-dash-distance', 8.0)}
    dash_speed: ${getValue('spire-dash-speed', 2.0)}
    knockback_strength: ${getValue('spire-knockback-strength', 1.5)}
    slow_duration: ${getValue('spire-slow-duration', 60)}
    vulnerable_duration: ${getValue('spire-vulnerable-duration', 100)}
    damage_amplification: ${getValue('spire-damage-amplification', 0.6)}
    cooldown: ${getValue('spire-cooldown', 30000)}

tide:
  primary:
    cooldown: ${getValue('tide-cooldown', 120000)}
    wave_width: ${getValue('tide-wave-width', 3.0)}
    effect_duration: ${getValue('tide-effect-duration', 300)}
    knockback_strength: ${getValue('tide-knockback-strength', 1.8)}
    wall_height: ${getValue('tide-wall-height', 6)}
    move_delay: ${getValue('tide-move-delay', 2)}
    max_moves: ${getValue('tide-max-moves', 20)}

wayfinder:
  primary:
    cooldown: ${getValue('wayfinder-cooldown', 120000)}

flow:
  primary:
    heart_cost_interval: ${getValue('flow-heart-cost-interval', 20)}
    heart_cost_amount: ${getValue('flow-heart-cost-amount', 2.0)}
    cooldown: ${getValue('flow-cooldown', 60000)}
    duration: ${getValue('flow-duration', 400)}

bolt:
  primary:
    cooldown: ${getValue('bolt-cooldown', 20000)}
    chain_range: ${getValue('bolt-chain-range', 10)}
    max_chains: ${getValue('bolt-max-chains', 3)}
    initial_damage: ${getValue('bolt-initial-damage', 6.0)}
    subsequent_damage: ${getValue('bolt-subsequent-damage', 4.0)}
    target_range: ${getValue('bolt-target-range', 20)}
    weakness_duration: ${getValue('bolt-weakness-duration', 100)}
    weakness_amplifier: ${getValue('bolt-weakness-amplifier', 0)}
`;
}

// Update YAML preview
function updateFullConfigPreview() {
  const yaml = generateYAML();
  document.getElementById('yaml-output').textContent = yaml;
}

// Copy YAML to clipboard
function copyConfig() {
  const text = document.getElementById('yaml-output').textContent;
  navigator.clipboard.writeText(text).then(() => {
    // Success feedback
    const btn = event.target;
    const originalText = btn.textContent;
    btn.textContent = 'âœ“ COPIED';
    btn.style.background = 'var(--mc-grass)';
    setTimeout(() => {
      btn.textContent = originalText;
      btn.style.background = '';
    }, 2000);
  }).catch(() => {
    alert('Failed to copy to clipboard. Please try selecting and copying manually.');
  });
}

// Download config as file
function downloadConfig() {
  const text = document.getElementById('yaml-output').textContent;
  const blob = new Blob([text], { type: 'text/yaml;charset=utf-8' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'config.yml';
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  window.URL.revokeObjectURL(url);

  // Success feedback
  const btn = event.target;
  const originalText = btn.textContent;
  btn.textContent = 'âœ“ DOWNLOADED';
  btn.style.background = 'var(--mc-grass)';
  setTimeout(() => {
    btn.textContent = originalText;
    btn.style.background = '';
  }, 2000);
}

// ==========================================
// RITUALS CONFIGURATION
// ==========================================

const RITUAL_TRIMS_LIST = [
  'sentry', 'silence', 'vex', 'ward', 'wild', 'coast', 'dune', 'eye',
  'host', 'raiser', 'rib', 'snout', 'spire', 'tide', 'wayfinder', 'flow', 'bolt'
];

function generateRitualsYAML() {
  let yaml = `# PowerTrims Rituals Configuration (rituals.yml)
# Generated by PowerTrims Config Builder
# Website: https://divi922.github.io/PowerTrimsWebsite/
#
# Check the guide for how to build the altar and perform rituals.

rituals:
`;

  RITUAL_TRIMS_LIST.forEach(trim => {
    // IDs: ritual-enable-{trim}, ritual-duration-{trim}, ritual-limit-{trim}, ritual-materials-{trim}
    // Note: For elements not yet rendered in HTML (if any), getValue default is used.
    // Sidebar toggles exist for all. Config inputs only for Sentry, Silence, Vex, Ward so far in HTML.

    const enabled = getValue(`ritual-enable-${trim}`, true);
    const duration = getValue(`ritual-duration-${trim}`, 10);
    const limit = getValue(`ritual-limit-${trim}`, 2);

    // Materials
    let materialsRaw = getValue(`ritual-materials-${trim}`, '');

    // Default fallbacks if empty AND element likely missing/empty
    // We only added HTML for Sentry, Silence, Vex, Ward. For others we need defaults to avoid empty strings if possible.
    // However, getValue returns '' if element missing.
    if (!materialsRaw && !document.getElementById(`ritual-materials-${trim}`)) {
      materialsRaw = "DIAMOND:1\nEMERALD:1";
    }

    // Parse materials
    let materialsList = '';
    if (materialsRaw) {
      const lines = materialsRaw.split('\n');
      lines.forEach(line => {
        const cleanLine = line.trim();
        if (cleanLine) {
          materialsList += `      - '${cleanLine}'\n`;
        }
      });
    }

    // Fallback if list is empty
    if (!materialsList) {
      materialsList = `      - 'DIAMOND:1'\n`;
    }


    const key = trim.toUpperCase();

    yaml += `  ${key}:
    # Set to false to disable this specific upgrade ritual.
    enabled: ${enabled}
    # Duration of the ritual in seconds.
    duration: ${duration}
    # Maximum number of times this armor set can be created. Set to -1 for no limit.
    limit: ${limit}
    # List of materials required for the ritual.
    materials:
${materialsList}`; // Newline included in materialsList
  });

  return yaml;
}

function updateRitualsPreview() {
  const yaml = generateRitualsYAML();
  const preview = document.getElementById('rituals-yaml-preview');
  if (preview) {
    preview.textContent = yaml;
  }
}

function copyRitualsConfig() {
  const yaml = generateRitualsYAML();
  navigator.clipboard.writeText(yaml).then(() => {
    const btn = document.querySelector('#page-rituals .copy-btn');
    if (btn) {
      const originalText = btn.textContent;
      btn.textContent = 'âœ“ COPIED';
      btn.style.background = 'var(--mc-grass)';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = '';
      }, 2000);
    }
  });
}

function downloadRitualsConfig() {
  const yaml = generateRitualsYAML();
  const blob = new Blob([yaml], { type: 'text/yaml;charset=utf-8' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'rituals.yml';
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  window.URL.revokeObjectURL(url);

  const btn = document.querySelector('#page-rituals .download-btn');
  if (btn) {
    const originalText = btn.textContent;
    btn.textContent = 'âœ“ DOWNLOADED';
    btn.style.background = 'var(--mc-grass)';
    setTimeout(() => {
      btn.textContent = originalText;
      btn.style.background = '';
    }, 2000);
  }
}

// ==========================================
// VISUAL RECIPE EDITOR (DRAG & DROP + ASSETS)
// ==========================================

let draggedItemSource = null; // Store { trimName, index }

function initRecipeEditor(trimName) {
  const grid = document.getElementById(`crafting-grid-${trimName}`);
  const textarea = document.getElementById(`ritual-materials-${trimName}`);
  if (!grid || !textarea) return;

  // Initialize State from Textarea (Attempt to fill linearly)
  // We use a fixed 9-slot array to support the grid layout
  const materialsRaw = textarea.value.trim();
  const state = new Array(9).fill(null);

  if (materialsRaw) {
    const lines = materialsRaw.split('\n');
    lines.forEach((line, idx) => {
      // Fill only up to 9 slots
      if (idx < 9) {
        const parts = line.split(':');
        if (parts.length >= 2) {
          state[idx] = {
            name: parts[0].trim(),
            amount: parseInt(parts[1]) || 1
          };
        }
      }
    });
  }

  // Attach state to DOM element for persistence during session
  grid.recipeState = state;

  // Initial render
  renderRecipeGrid(trimName);
}

function renderRecipeGrid(trimName) {
  const grid = document.getElementById(`crafting-grid-${trimName}`);
  if (!grid || !grid.recipeState) return;

  const items = grid.recipeState; // Array of 9 (objects or null)
  grid.innerHTML = '';

  // 9 Slots (3x3)
  for (let i = 0; i < 9; i++) {
    const slot = document.createElement('div');
    slot.className = 'crafting-slot';

    // Drag & Drop Events (Slot is a drop target)
    slot.ondragover = (e) => { e.preventDefault(); }; // Allow drop
    slot.ondrop = (e) => handleSlotDrop(e, trimName, i);

    // Click handler for editing
    slot.onclick = () => handleSlotClick(trimName, i);

    const item = items[i];
    if (item) {
      // Draggable Item
      slot.draggable = true;
      slot.ondragstart = (e) => handleDragStart(e, trimName, i);

      // Content
      const content = document.createElement('div');
      content.className = 'slot-content';

      // 1. Image from Assets
      // Using standard Minecraft naming convention: 'diamond_block' -> 'diamond_block.png'
      const imgName = item.name.toLowerCase().replace(/minecraft:/g, '');
      const img = document.createElement('img');
      img.src = `assets/Minecraft_Items_latest_AllVisible/${imgName}.png`;
      img.className = 'slot-image';
      img.alt = item.name;
      // Fallback if image not found
      img.onerror = function () {
        this.style.display = 'none';
        this.nextElementSibling.style.display = 'block';
      };

      content.appendChild(img);

      // 2. Fallback Icon (initially hidden)
      const fallback = document.createElement('div');
      fallback.className = 'slot-icon slot-icon-fallback';
      fallback.textContent = 'ðŸ“¦'; // Default box
      fallback.style.display = 'none';
      content.appendChild(fallback);

      // 3. Tooltip Name (Hover)
      slot.title = `${item.name}${item.amount > 1 ? ` x${item.amount}` : ''}`;

      // 4. Count (Minecraft style: hide 1)
      if (item.amount > 1) {
        const count = document.createElement('div');
        count.className = 'slot-count';
        count.textContent = item.amount;
        slot.appendChild(count);
      }

      slot.appendChild(content);
    } else {
      slot.title = "Empty Slot";
    }

    grid.appendChild(slot);
  }
}

// Drag Handlers
function handleDragStart(e, trimName, index) {
  draggedItemSource = { trimName, index };
  e.dataTransfer.effectAllowed = 'move';
  // Optional: Set drag image
}

function handleSlotDrop(e, trimName, index) {
  e.preventDefault();

  if (!draggedItemSource || draggedItemSource.trimName !== trimName) return;

  const fromIndex = draggedItemSource.index;
  const toIndex = index;

  if (fromIndex === toIndex) return;

  const grid = document.getElementById(`crafting-grid-${trimName}`);
  const state = grid.recipeState;

  // Swap Items
  const temp = state[toIndex];
  state[toIndex] = state[fromIndex];
  state[fromIndex] = temp;

  renderRecipeGrid(trimName);
  syncStateToTextarea(trimName);

  draggedItemSource = null;
}

function handleSlotClick(trimName, index) {
  const grid = document.getElementById(`crafting-grid-${trimName}`);
  const state = grid.recipeState;
  const item = state[index];

  // Prompt Logic
  // If item exists: Edit Name/Amount or Clear
  // If empty: Add Name
  const promptText = item ? `Edit Material (Current: ${item.name})\nClear text to remove.` : "Add Material (e.g. DIAMOND_BLOCK):";
  const defaultVal = item ? item.name : "";

  let newName = prompt(promptText, defaultVal);
  if (newName === null) return; // Cancelled

  newName = newName.trim().toUpperCase();

  if (newName === '') {
    // Clear slot
    state[index] = null;
  } else {
    // Set/Update item
    let newAmount = 1;
    if (item) {
      // Ask for amount if editing
      const amountStr = prompt("Amount:", item.amount);
      if (amountStr !== null) {
        newAmount = parseInt(amountStr) || 1;
      } else {
        return; // Cancelled amount update
      }
    } else {
      // New item, default 1, or ask?
      // Let's ask for amount for new items too
      const amountStr = prompt("Amount:", "1");
      if (amountStr !== null) {
        newAmount = parseInt(amountStr) || 1;
      }
    }

    state[index] = { name: newName, amount: newAmount };
  }

  renderRecipeGrid(trimName);
  syncStateToTextarea(trimName);
}

function syncStateToTextarea(trimName) {
  const grid = document.getElementById(`crafting-grid-${trimName}`);
  const textarea = document.getElementById(`ritual-materials-${trimName}`);

  // Filter out nulls for the YAML list
  // Note: This means reloading the page will lose empty gaps, 
  // but dragging/editing within the session preserves them.
  const validItems = grid.recipeState.filter(i => i !== null);

  let text = '';
  validItems.forEach(item => {
    text += `${item.name}:${item.amount}\n`;
  });

  textarea.value = text.trim();
  updateRitualsPreview();
}

function clearRecipe(trimName) {
  if (confirm('Clear all ingredients?')) {
    const grid = document.getElementById(`crafting-grid-${trimName}`);
    grid.recipeState = new Array(9).fill(null);
    renderRecipeGrid(trimName);
    syncStateToTextarea(trimName);
  }
}


// Initialize config builder on page load
document.addEventListener('DOMContentLoaded', () => {
  // Generate initial Main Config YAML
  if (typeof updateFullConfigPreview === 'function') {
    updateFullConfigPreview();
  }

  // Generate initial Rituals YAML
  updateRitualsPreview();

  // Initialize Recipe Editors
  initRecipeEditor('silence');
  // Future: TRIMS_LIST.forEach(t => initRecipeEditor(t));
});

